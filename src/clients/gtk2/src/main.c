/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <gtk/gtk.h>

#include "interface.h"
#include "support.h"

#include <xmmsclient.h>

enum status_codes {
	STOP,
	PLAY
};

GtkWidget *playlistwin=NULL;
GtkWidget *mainwindow;
xmmsc_connection_t *conn;
gint lasttime;
gint state;

static GdkPixbuf *
get_icon ()
{
	GtkWidget *image;
	image = gtk_image_new_from_file ("cdaudio_mount.png");
	if (!image) {
		printf ("auf\n");
	}
	return gtk_image_get_pixbuf(GTK_IMAGE(image));
}

void
fill_playlist ()
{
	GtkTreeStore *store;
	GtkTreeIter iter1;
	GtkCellRenderer *renderer, *renderer_img;
	GtkTreeViewColumn *column;
	GList *node;
	GtkWidget *tree = lookup_widget (playlistwin, "treeview1");
	gint id = xmmsc_get_playing_id (conn);
	GList *list = xmmsc_playlist_list (conn);

	store = gtk_tree_store_new (3, GDK_TYPE_PIXBUF, G_TYPE_STRING, G_TYPE_INT);

	for (node = list; node; node = g_list_next (node)) {
		gchar *file;
		xmmsc_playlist_entry_t *entry = node->data;
	
		file = strrchr (entry->url, '/');
		
		gtk_tree_store_append (store, &iter1, NULL);
		
		if (id == entry->id) {
			printf ("%d\n", entry->id);
			gtk_tree_store_set (store, &iter1, 
					0, get_icon (), 
					1, file+1, 
					2, entry->id, 
					-1);
		} else {
			gtk_tree_store_set (store, &iter1, 
					1, file+1, 
					2, entry->id, 
					-1);
		}
	}

	gtk_tree_view_set_model (GTK_TREE_VIEW (tree), GTK_TREE_MODEL (store));
	g_object_unref (G_OBJECT (store));

	renderer = gtk_cell_renderer_text_new ();
	renderer_img = gtk_cell_renderer_pixbuf_new ();

	column = gtk_tree_view_column_new_with_attributes ("icon", renderer_img,
				"pixbuf", 0,
				NULL);
	
	gtk_tree_view_append_column (GTK_TREE_VIEW (tree), column);

	column = gtk_tree_view_column_new_with_attributes ("File", renderer,
				"text", 1,
				NULL);

	gtk_tree_view_append_column (GTK_TREE_VIEW (tree), column);

}


static void
mediainfo (gint id)
{
	GHashTable *entry;
	GtkWidget *title = lookup_widget (mainwindow, "title");
	GtkWidget *range = lookup_widget (mainwindow, "hscale1");

	if (id > 0) {
		gchar *tmp;

		lasttime = 0;

		entry = xmmsc_playlist_get_mediainfo (conn, id);
		if (!entry)
			return;

		tmp = (gchar *)g_hash_table_lookup (entry, "duration");
		if (tmp)
			gtk_range_set_range (GTK_RANGE (range), 0, (gdouble) atoi (tmp));
		else
			gtk_range_set_range (GTK_RANGE (range), 0, 0);

		tmp = (gchar *)g_hash_table_lookup (entry, "title");
		if (tmp) {
			gtk_label_set_text (GTK_LABEL (title), tmp);
		} else {
			tmp = (gchar *)g_hash_table_lookup (entry, "uri");
			tmp = strrchr (tmp, '/');
			gtk_label_set_text (GTK_LABEL (title), tmp+1);
		}

		state = PLAY;

		xmmsc_playlist_entry_free (entry);
		
	} else {
		gtk_label_set_text (GTK_LABEL (title), "xmms2 - it really whips the GNUs ass");
		gtk_range_set_range (GTK_RANGE (range), 0, 0);
	}
}

static void
handle_playtime (void *userdata, void *arg)
{
	guint tme = GPOINTER_TO_UINT (arg) / 1000;
	GtkWidget *range = lookup_widget (mainwindow, "hscale1");

	if (state == STOP) {
		gtk_range_set_value (GTK_RANGE (range), 0);
		return;
	}

	if (tme > lasttime) {
		gtk_range_set_value (GTK_RANGE (range), (gdouble)(tme));
		lasttime = tme;
	}
}
static void
handle_information (void *userdata, void *arg)
{
}
static void
handle_mediainfo (void *userdata, void *arg)
{
	gint id = GPOINTER_TO_UINT (arg);

	mediainfo (id);
}
static void
handle_playback_stopped (void *userdata, void *arg)
{
	printf ("Stopped!\n");
	state = STOP;
	mediainfo (0);
}
static void
handle_disconnected (void *userdata, void *arg)
{
}

static void
buttonset_sensitive (gboolean sens)
{
	GtkWidget *tmp;

	tmp = lookup_widget (mainwindow, "play");
	gtk_widget_set_sensitive (tmp, sens);
	tmp = lookup_widget (mainwindow, "stop");
	gtk_widget_set_sensitive (tmp, sens);
	tmp = lookup_widget (mainwindow, "next");
	gtk_widget_set_sensitive (tmp, sens);
	tmp = lookup_widget (mainwindow, "prev");
	gtk_widget_set_sensitive (tmp, sens);
	tmp = lookup_widget (mainwindow, "playlist");
	gtk_widget_set_sensitive (tmp, sens);
}

int
main (int argc, char *argv[])
{
	gtk_set_locale ();
	gtk_init (&argc, &argv);
	GtkWidget *title;

	add_pixmap_directory (PACKAGE_DATA_DIR "/" PACKAGE "/pixmaps");

	mainwindow = create_mainwindow ();

	title = lookup_widget (mainwindow, "title");
	
	gtk_widget_show (mainwindow);

	/* connect */
	conn = xmmsc_init ();
	state = STOP;

	if (!conn) {
		return 1;
	}

	if (!xmmsc_connect (conn)) {
		gtk_label_set_text (GTK_LABEL (title), "failed to connect!");
		buttonset_sensitive (FALSE);
	} else {
		/* set up xmmsclient callbacks */
		xmmsc_set_callback (conn, XMMSC_CALLBACK_PLAYTIME_CHANGED, handle_playtime, NULL);
		xmmsc_set_callback (conn, XMMSC_CALLBACK_INFORMATION, handle_information, NULL);
		xmmsc_set_callback (conn, XMMSC_CALLBACK_MEDIAINFO_CHANGED, handle_mediainfo, conn);
		xmmsc_set_callback (conn, XMMSC_CALLBACK_PLAYBACK_STOPPED, handle_playback_stopped, conn);
		xmmsc_set_callback (conn, XMMSC_CALLBACK_DISCONNECTED, handle_disconnected, conn);
		xmmsc_glib_setup_mainloop (conn, NULL);

		mediainfo (xmmsc_get_playing_id (conn));
	}

	gtk_main ();
	return 0;
}

